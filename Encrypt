for i, bot in pairs(getBots()) do
    if getBot().name:upper() == bot.name:upper() then
        param = i
    end
end

mode = bot[param].mode
startfrom = bot[param].startfrom
farmList = bot[param].farmList
idList = bot[param].idList
infoid = {}
local identity = {}
identity.param = idList
identity.status = setting.webhook.botstatus.url
identity.webhook = setting.webhook.infoworld.url
identity.message = setting.webhook.infoworld.messageid
strings = ""
index = 1
local tileDrop = 0
dropX = setting.storage.worldDrop.dropposition.x - 1
dropY = setting.storage.worldDrop.dropposition.y - 1

identity.round = function(n)
    return n % 1 > 0.5 and math.ceil(n) or math.floor(n)
end

identity.takename = function()
    strings = ""
	for i = 1, #setting.storage.worldTake.world do
		strings = strings.."\n||"..string.upper(setting.storage.worldTake.world[i]).."|| "..(infoid[setting.storage.worldTake.world[i]] or "?")..""
    end
    return strings
end

identity.dropname = function()
    strings = ""
	for i = 1, #setting.storage.worldDrop.world do
		strings = strings.."\n||"..string.upper(setting.storage.worldDrop.world[i]).."|| "..(infoid[setting.storage.worldDrop.world[i]] or "?")..""
    end
    return strings
end

identity.farmname = function()
    strings = ""
	for i = 1, #farmList do
		strings = strings.."\n||"..string.upper(farmList[i]).."|| "..(infoid[farmList[i]] or "?")..""
	end
	return strings
end

identity.itemFloat = function(id)
	local count = 0
	for _, obj in pairs(getObjects()) do
		if obj.id == id then
			count = count + obj.count
		end
	end
	return count
end

identity.webhookinfo = function()
	if setting.webhook.access then
        if not collectfromfarm then
            local text = [[
                $webHookUrl = "]]..identity.webhook..[[/messages/]]..identity.message..[["
                $payload = @{
                    username = "BizzantiuM's"
                    embeds = @(
                        @{
                            title = "AUTO MOVE v1.0"
                            color = "]]..math.random(111111,999999)..[["
                            fields = @(
                                @{
                                    name = "STORAGE STATIC"
                                    value = "]]..""..[["
                                    inline = "false"
                                }
                                @{
                                    name = "WORLD TAKE"
                                    value = "]]..identity.takename()..[["
                                    inline = "true"
                                }
                                @{
                                    name = "WORLD DROP"
                                    value = "]]..identity.dropname()..[["
                                    inline = "true"
                                }
                            )
                            footer = @{
                                text = "Developed by BizzantiuM's`nLast updated : ]]..(os.date"%d/%m/%y":upper().." at ")..os.date("%I")..":"..os.date("%M").." "..os.date("%p"):upper()..[["
                            }
                        }
                    )
                }
                [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
                Invoke-RestMethod -Uri $webHookUrl -Body ($payload | ConvertTo-Json -Depth 4) -Method Patch -ContentType 'application/json'
            ]]
            local pipe = io.popen("powershell -command -", "w")
            pipe:write(text)
            pipe:close()
        else
            local text = [[
                $webHookUrl = "]]..identity.webhook..[[/messages/]]..identity.message..[["
                $payload = @{
                    username = "BizzantiuM's"
                    embeds = @(
                        @{
                            title = "AUTO MOVE v1.0"
                            color = "]]..math.random(111111,999999)..[["
                            fields = @(
                                @{
                                    name = "STORAGE STATIC"
                                    value = "]]..""..[["
                                    inline = "false"
                                }
                                @{
                                    name = "WORLD DROP"
                                    value = "]]..identity.dropname()..[["
                                    inline = "false"
                                }
                                @{
                                    name = "WORLD TAKE"
                                    value = "]]..identity.farmname()..[["
                                    inline = "false"
                                }
                            )
                            footer = @{
                                text = "Developed by BizzantiuM's`nLast updated : ]]..(os.date"%d/%m/%y":upper().." at ")..os.date("%I")..":"..os.date("%M").." "..os.date("%p"):upper()..[["
                            }
                        }
                    )
                }
                [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
                Invoke-RestMethod -Uri $webHookUrl -Body ($payload | ConvertTo-Json -Depth 4) -Method Patch -ContentType 'application/json'
            ]]
            local pipe = io.popen("powershell -command -", "w")
            pipe:write(text)
            pipe:close()
        end
    end
end

identity.botinfo = function(text)
    if setting.webhook.access then
        text = [[
            $webHookUrl = "]]..identity.status..[["
            $payload = @{
                content = "]]..text..[["
            }
            [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
            Invoke-RestMethod -Uri $webHookUrl -Body ($payload | ConvertTo-Json -Depth 4) -Method Post -ContentType "application/json"
        ]]
        local file = io.popen("powershell -command -", "w")
        file:write(text)
        file:close()
    end
end

identity.warp = function(world,door)
    name = world
    door = identity.door
    if identity.door then
        name = name .. "|" ..identity.door
    end
    if getBot().world ~= string.upper(world) then
        addHook("onvariant","nuked",function (varlist)
            if varlist[0] == "OnConsoleMessage" then
                if string.find(varlist[1],"inaccessible.") then
                    nuked = true
                end
            end
        end)
        while getBot().world ~= string.upper(world) and not nuked do
            sendPacket("action|join_request\nname|"..name.."\ninvitedWorld|0",3)
            sleep(setting.delay.warp)
        end
        removeHooks()
        sleep(1000)
    end
    if identity.door and getBot().world == string.upper(world) then
        local stuck = 0
        while getTile(math.floor(getBot().x / 32),math.floor(getBot().y / 32)).fg == 6 and not wrong do
            sendPacket("action|join_request\nname|"..name.."\ninvitedWorld|0",3)
            sleep(setting.delay.warp)
            stuck = stuck + 1
            if stuck == 5 then
                wrong = true
            end
        end
    end
end

identity.reconnect = function(world,id,x,y)
    if getBot().status ~= "online" then
        identity.botinfo("[ ||"..getBot().name.."|| ] status is "..getBot().status.." @everyone")
        print("[ "..getBot().name.." ] status is "..getBot().status.."")
        while getBot().status ~= "online" do
            connect()
            sleep(setting.delay.reconnect)
            if getBot().status == "suspended" or getBot().status == "banned" or getBot().status == "ercon" then
                identity.botinfo("[ ||"..getBot().name.."|| ] status is "..getBot().status..", removing bot @everyone")
                print("[ "..getBot().name.." ] status is "..getBot().status..", removing bot")
                if setting.mode.removeBot then
                    removeBot(getBot().name)
                    sleep(100)
                end
                error()
            end
        end
        while getBot().world ~= world:upper() do
            sendPacket("action|join_request\nname|"..world:upper().."\ninvitedWorld|0",3)
            sleep(setting.delay.warp)
        end
        while getTile(math.floor(getBot().x / 32),math.floor(getBot().y / 32)).fg == 6 do
            sendPacket("action|join_request\nname|" ..world:upper().."|"..id:upper().."\ninvitedWorld|0", 3)
            sleep(setting.delay.warp)
            if getTile(math.floor(getBot().x / 32),math.floor(getBot().y / 32)).fg ~= 6 then
                while math.floor(getBot().x / 32) ~= x or math.floor(getBot().y / 32) ~= y do
                    findPath(x,y)
                    sleep(150)
                end
            end
        end
        identity.botinfo("[ ||"..getBot().name.."|| ] status is "..getBot().status.." @everyone")
        print("[ "..getBot().name.." ] status is "..getBot().status.."")
    end
    if getTile(math.floor(getBot().x / 32),math.floor(getBot().y / 32)).fg == 6 then
        local count = 0
        while getTile(math.floor(getBot().x / 32),math.floor(getBot().y / 32)).fg == 6 do
            count = count + 1
            sendPacket("action|join_request\nname|" ..world:upper().."|"..id:upper().."\ninvitedWorld|0", 3)
            sleep(setting.delay.warp)
            if count == 5 then
                count = 0
                disconnect()
                sleep(2000)
            end
        end
        while math.floor(getBot().x / 32) ~= x or math.floor(getBot().y / 32) ~= y do
            findPath(x,y)
            sleep(150)
        end
    end
end

identity.storingitems = function(threads)
    for i = index , #setting.storage.worldDrop.world do
        setJob("Dropping items")
        world = setting.storage.worldDrop.world[i]
        identity.door = setting.storage.worldDrop.door
        identity.warp(world,identity.door)
        if not nuked then
            if not wrong then
                if identity.itemFloat(setting.itemId[1]) >= setting.storage.worldDrop.limit then
                    infoid[world] = "["..identity.itemFloat(setting.itemId[1]).."] LIMIT !!!"
                    identity.botinfo("Drop storage : [ ||"..getBot().world.."|| ] has reached limit, skipped world @everyone")
                    print("Drop storage : [ "..getBot().world.." ] has reached limit, skipped world")
                    index = index + 1
                    if index > #setting.storage.worldDrop.world then
                        infoid[world] = "["..identity.itemFloat(setting.itemId[1]).."] LIMIT !!!"
                        identity.botinfo("All drop storage has reached limit, Removing bot : [ ||"..getBot().name.."|| ] @everyone")
                        print("All drop storage has reached limit, Removing bot : [ "..getBot().name.." ]")
                        identity.webhookinfo()
                        if setting.mode.removeBot then
                            removeBot(getBot().name)
                            sleep(100)
                        end
                        error()
                    end
                    tileDrop = 0
                else
                    for y,pack in pairs(setting.itemId) do
                        for i,tile in pairs(getTiles()) do
                            if setting.mode.separated then
                                if tile.fg == 0 or tile.bg == 0 then
                                    ::BACK::
                                    findPath(dropX + (tileDrop),dropY - (y-1))
                                    sleep(1000)
                                    local count = 0
                                    identity.reconnect(world,identity.door,dropX + (tileDrop),dropY - (y-1))
                                    if dropX + (tileDrop) >= 98 then
                                        dropY = dropY - 1
                                        tileDrop = 0
                                    end
                                    while findItem(pack) > 0 do
                                        drop(pack)
                                        sleep(setting.delay.drop)
                                        identity.reconnect(world,identity.door,dropX + (tileDrop),dropY - (y-1))
                                        count = count + 1
                                        if count >= 2 then
                                            tileDrop = tileDrop + 1
                                            goto BACK
                                        end
                                    end
                                end
                            else
                                if tile.fg == 0 or tile.bg == 0 then
                                    ::BACK::
                                    findPath(dropX + (tileDrop),dropY)
                                    sleep(1000)
                                    local count = 0
                                    identity.reconnect(world,identity.door,dropX + (tileDrop),dropY)
                                    if dropX + (tileDrop) >= 98 then
                                        dropY = dropY - 1
                                        tileDrop = 0
                                    end
                                    while findItem(pack) > 0 do
                                        drop(pack)
                                        sleep(setting.delay.drop)
                                        identity.reconnect(world,identity.door,dropX + (tileDrop),dropY)
                                        count = count + 1
                                        if count >= 2 then
                                            tileDrop = tileDrop + 1
                                            goto BACK
                                        end
                                    end
                                end
                            end
                            if findItem(pack) == 0 then
                                break
                            end
                        end
                    end
                    sleep(100)
                    break
                end
            else
                infoid[world] = "WRONG DOOR !!!"
                wrong = false
                sleep(1000)
                print("[ "..getBot().world.." ] Id door drop storage is wrong, check ur id door!")
                identity.botinfo("[ ||"..getBot().world.."|| ] Id door drop storage is wrong, check ur id door! @everyone")
                index = index + 1
                if index > #setting.storage.worldDrop.world then
                    print("All drop storage has reached limit")
                    identity.botinfo("All drop storage has reached limit! Removing bot : [ ||"..getBot().name.."|| ] @everyone")
                    identity.webhookinfo()
                    if setting.mode.removeBot then
                        removeBot(getBot().name)
                        sleep(100)
                    end
                    error()
                end
                tileDrop = 0
            end
        else
            infoid[world] = "NUKED !!!"
            nuked = false
            sleep(1000)
            print("[ "..getBot().world.." ] drop Storage is NUKED, check ur storage!")
            identity.botinfo("[ "..getBot().world.." ] drop Storage is NUKED, check ur storage! @everyone")
            index = index + 1
            if index > #setting.storage.worldDrop.world then
                print("All drop storage has reached limit!")
                identity.botinfo("All drop storage has reached limit! Removing bot : [ ||"..getBot().name.."|| ] @everyone")
                identity.webhookinfo()
                if setting.mode.removeBot then
                    removeBot(getBot().name)
                    sleep(100)
                end
                error()
            end
            tileDrop = 0
        end
    end
    infoid[world] = "["..identity.itemFloat(setting.itemId[1]).."]"
    identity.webhookinfo()
end

identity.takestorage = function()
    for i = index , #setting.storage.worldTake.world do
        setJob("Taking items")
        world = setting.storage.worldTake.world[i]
        identity.door = setting.storage.worldTake.door
        identity.warp(world,identity.door)
        if not nuked then
            if not wrong then
                if identity.itemFloat(setting.itemId[1]) == 0 then
                    infoid[world] = "["..identity.itemFloat(setting.itemId[1]).."] EMPTY !!!"
                    identity.botinfo("Take storage : [ ||"..getBot().world.."|| ] has empty, skipped world @everyone")
                    print("Take storage : [ "..getBot().world.." ] has empty, skipped world")
                    index = index + 1
                    if index > #setting.storage.worldTake.world then
                        infoid[world] = "["..identity.itemFloat(setting.itemId[1]).."] EMPTY !!!"
                        identity.botinfo("All take storage has empty, Removing bot : [ ||"..getBot().name.."|| ] @everyone")
                        print("All take storage has empty, Removing bot : [ "..getBot().name.." ]")
                        identity.webhookinfo()
                        if setting.mode.removeBot then
                            removeBot(getBot().name)
                            sleep(100)
                        end
                        error()
                    end
                else
                    for _, pack in pairs(setting.itemId) do
                        while findItem(pack) == 0 do
                            for _, object in pairs(getObjects()) do
                                if object.id == pack then
                                    findPath(identity.round((object.x)/32), math.floor((object.y)/32))
                                    sleep(500)
                                    collect(setting.mode.range)
                                    identity.reconnect(world,identity.door,identity.round((object.x)/32), math.floor((object.y)/32))
                                end
                                if findItem(pack) > 0 then
                                    break
                                end
                            end
                        end
                    end
                    sleep(100)
                    break
                end
            else
                infoid[world] = "WRONG DOOR !!!"
                wrong = false
                sleep(1000)
                print("[ "..getBot().world.." ] Id door take storage is wrong, check ur id door!")
                identity.botinfo("[ ||"..getBot().world.."|| ] Id door take storage is wrong, check ur id door! @everyone")
                index = index + 1
                if index > #setting.storage.worldTake.world then
                    print("All take storage has empty")
                    identity.botinfo("All take storage has empty! Removing bot : [ ||"..getBot().name.."|| ] @everyone")
                    identity.webhookinfo()
                    if setting.mode.removeBot then
                        removeBot(getBot().name)
                        sleep(100)
                    end
                    error()
                end
            end
        else
            infoid[world] = "NUKED !!!"
            nuked = false
            sleep(1000)
            print("[ "..getBot().world.." ] take Storage is NUKED, check ur storage!")
            identity.botinfo("[ "..getBot().world.." ] take Storage is NUKED, check ur storage! @everyone")
            index = index + 1
            if index > #setting.storage.worldTake.world then
                print("All take storage has empty!")
                identity.botinfo("All drop storage has empty! Removing bot : [ ||"..getBot().name.."|| ] @everyone")
                identity.webhookinfo()
                if setting.mode.removeBot then
                    removeBot(getBot().name)
                    sleep(100)
                end
                error()
            end
        end
    end
    infoid[world] = "["..identity.itemFloat(setting.itemId[1]).."]"
    identity.webhookinfo()
end

identity.take = function(threads)
    tileA = 99
    tileB = 0
    tileC = -1
    tileD = 0
    if collectfromfarm then
        for i , object in pairs(getObjects()) do
            if object.id == setting.itemId[1] then
                for y = -1, 53 do
                    for x = tileA, tileB, tileC do
                        if getTile(x, y).fg == 0 and getTile(x, y + 1).flags ~= 0 and identity.itemFloat(setting.itemId[1]) ~= 0 then
                            infoid[threads] = ""..identity.itemFloat(setting.itemId[1])..""
                            if findItem(setting.itemId[1]) > 180 then
                                identity.storingitems(threads)
                                setJob("Collect from farm")
                                identity.door = identity.param
                                identity.warp(threads,identity.door)
                                identity.webhookinfo()
                            end
                            identity.door = identity.param
                            findPath(x,y)
                            identity.reconnect(threads,identity.door,x,y)
                            if setting.mode.ignoregems then
                                collect(setting.mode.range)
                            else
                                collect(setting.mode.range)
                            end
                            sleep(delaycollect)
                        end
                    end
                    if tileD == 1 then
                        if tileA == 0 then
                            tileA = 99
                            tileB = 0
                            tileC = -1
                            tileD = 0
                        elseif tileA == 99 then
                            tileA = 0
                            tileB = 99
                            tileC = 1
                            tileD = 0
                        end
                    elseif tileD == 0 then
                        tileD = tileD + 1
                    end
                end
            end
        end
    end
end

if BizzantiuM.version == "1.0" and BizzantiuM.handler == "akbarsht" then
    sleep(math.random(100,3000))
    if collectfromfarm then
        for i = startfrom, #farmList do
            identity.door = identity.param
            setJob("Collect from farm")
            identity.webhookinfo()
            identity.warp(farmList[i],identity.door)
            if not nuked then
                if not wrong then
                    identity.take(farmList[i])
                else
                    infoid[farmList[i]] = "WRONG DOOR ID"
                    wrong = false
                    sleep(1000)
                    print(""..farmList[i].." is wrong door id, skipped world")
                    identity.botinfo("[ ||"..farmList[i].."|| ] is wrong door id, skipped world @everyone")
                end
            else
                infoid[farmList[i]] = "NUKED"
                nuked = false
                sleep(1000)
                print(""..farmList[i].." is NUKED!, check ur world !!")
                identity.botinfo("[ ||"..farmList[i].."|| ] is NUKED!, check ur world !! @everyone")
            end
        end
    else
        while true do
            identity.takestorage()
            identity.storingitems(threads)
        end
    end
end
